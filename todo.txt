WEBSITE

- add a speed slider
- add a array len slider

- add info for all the algos



INFO THINGY:


Bubble Sort
Description: Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.

How it works:

Compare the first two elements.
If the first element is greater than the second, swap them.
Move to the next pair of elements and repeat the process until the end of the list.
Repeat the entire process for the entire list until no swaps are needed.
Time Complexity:

Best Case: O(n)
Average Case: O(n^2)
Worst Case: O(n^2)
Selection Sort
Description: Selection Sort is an in-place comparison-based sorting algorithm. It divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list.

How it works:

Find the minimum element in the unsorted part of the list.
Swap it with the first unsorted element.
Move the boundary of the sorted and unsorted sublists one element to the right.
Repeat until the entire list is sorted.
Time Complexity:

Best Case: O(n^2)
Average Case: O(n^2)
Worst Case: O(n^2)
Insertion Sort
Description: Insertion Sort is a simple comparison-based sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.

How it works:

Start with the second element (the first element is considered sorted).
Compare the current element with the sorted elements and insert it into the correct position.
Repeat for all elements until the list is sorted.
Time Complexity:

Best Case: O(n)
Average Case: O(n^2)
Worst Case: O(n^2)
Merge Sort
Description: Merge Sort is a divide-and-conquer algorithm that was invented by John von Neumann in 1945. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.

How it works:

Divide the array into two halves.
Recursively sort each half.
Merge the two halves to produce the sorted array.
Time Complexity:

Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n log n)
Quick Sort
Description: Quick Sort is a highly efficient sorting algorithm and is based on partitioning of the array of data into smaller arrays. A large array is partitioned into two arrays, one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.

How it works:

Pick a pivot element.
Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.
Recursively apply the above steps to the sub-arrays.
Time Complexity:

Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n^2)
Heap Sort
Description: Heap Sort is a comparison-based sorting technique based on a binary heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for the remaining elements.

How it works:

Build a max heap from the input data.
At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of the heap by 1. Finally, heapify the root of the tree.
Repeat step 2 while the size of the heap is greater than 1.
Time Complexity:

Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n log n)
Counting Sort
Description: Counting Sort is an integer sorting algorithm that operates by counting the number of objects that have distinct key values (kind of hashing). It is not a comparison-based sorting algorithm and its running time complexity is O(n) with space proportional to the range of the data.

How it works:

Find the range of the input data.
Create a count array to store the count of each unique object.
Modify the count array such that each element at each index stores the sum of previous counts.
Output each object from the input sequence followed by decreasing its count by 1.
Time Complexity:

Best Case: O(n + k)
Average Case: O(n + k)
Worst Case: O(n + k)
Radix Sort
Description: Radix Sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered.

How it works:

Sort the elements based on the least significant digit.
Repeat the process for each digit, moving towards the most significant digit.
Time Complexity:

Best Case: O(nk)
Average Case: O(nk)
Worst Case: O(nk)
Where n is the number of elements and k is the number of digits in the largest number.