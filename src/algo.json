{
    "algorithms": [
      {
        "name": "Bubble Sort",
        "description": "Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.",
        "how_it_works": [
          "Compare the first two elements.",
          "If the first element is greater than the second, swap them.",
          "Move to the next pair of elements and repeat the process until the end of the list.",
          "Repeat the entire process for the entire list until no swaps are needed."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Selection Sort",
        "description": "Selection Sort is an in-place comparison-based sorting algorithm. It divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list.",
        "how_it_works": [
          "Find the minimum element in the unsorted part of the list.",
          "Swap it with the first unsorted element.",
          "Move the boundary of the sorted and unsorted sublists one element to the right.",
          "Repeat until the entire list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n^2)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Insertion Sort",
        "description": "Insertion Sort is a simple comparison-based sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.",
        "how_it_works": [
          "Start with the second element (the first element is considered sorted).",
          "Compare the current element with the sorted elements and insert it into the correct position.",
          "Repeat for all elements until the list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Merge Sort",
        "description": "Merge Sort is a divide-and-conquer algorithm that was invented by John von Neumann in 1945. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.",
        "how_it_works": [
          "Divide the array into two halves.",
          "Recursively sort each half.",
          "Merge the two halves to produce the sorted array."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n log n)",
          "worst_case": "O(n log n)"
        }
      },
      {
        "name": "Quick Sort",
        "description": "Quick Sort is a highly efficient sorting algorithm and is based on partitioning of the array of data into smaller arrays. A large array is partitioned into two arrays, one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.",
        "how_it_works": [
          "Pick a pivot element.",
          "Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.",
          "Recursively apply the above steps to the sub-arrays."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n log n)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Heap Sort",
        "description": "Heap Sort is a comparison-based sorting technique based on a binary heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for the remaining elements.",
        "how_it_works": [
          "Build a max heap from the input data.",
          "At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of the heap by 1. Finally, heapify the root of the tree.",
          "Repeat step 2 while the size of the heap is greater than 1."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n log n)",
          "worst_case": "O(n log n)"
        }
      },
      {
        "name": "Counting Sort",
        "description": "Counting Sort is an integer sorting algorithm that operates by counting the number of objects that have distinct key values (kind of hashing). It is not a comparison-based sorting algorithm and its running time complexity is O(n) with space proportional to the range of the data.",
        "how_it_works": [
          "Find the range of the input data.",
          "Create a count array to store the count of each unique object.",
          "Modify the count array such that each element at each index stores the sum of previous counts.",
          "Output each object from the input sequence followed by decreasing its count by 1."
        ],
        "time_complexity": {
          "best_case": "O(n + k)",
          "average_case": "O(n + k)",
          "worst_case": "O(n + k)"
        }
      },
      {
        "name": "Radix Sort",
        "description": "Radix Sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered.",
        "how_it_works": [
          "Sort the elements based on the least significant digit.",
          "Repeat the process for each digit, moving towards the most significant digit."
        ],
        "time_complexity": {
          "best_case": "O(nk)",
          "average_case": "O(nk)",
          "worst_case": "O(nk)"
        }
      },
      {
        "name": "Bingo Sort Algorithm",
        "how_it_works": [
          "Find the largest element and move it to the end.",
          "Repeat the process for the remaining elements."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "ShellSort",
        "how_it_works": [
          "Divide the list into smaller sublists using a gap sequence.",
          "Sort each sublist using insertion sort.",
          "Reduce the gap and repeat until the gap is 1."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n log^2 n)",
          "worst_case": "O(n log^2 n)"
        }
      },
      {
        "name": "TimSort",
        "how_it_works": [
          "Divide the list into small runs and sort each run using insertion sort.",
          "Merge the runs using merge sort."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n log n)",
          "worst_case": "O(n log n)"
        }
      },
      {
        "name": "Comb Sort",
        "how_it_works": [
          "Initialize the gap to the length of the list.",
          "Compare and swap elements that are gap distance apart.",
          "Reduce the gap and repeat until the gap is 1."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n^2 / 2^p)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Pigeonhole Sort",
        "how_it_works": [
          "Find the range of the elements.",
          "Create pigeonholes for each element in the range.",
          "Place each element in its corresponding pigeonhole.",
          "Collect the elements from the pigeonholes."
        ],
        "time_complexity": {
          "best_case": "O(n + k)",
          "average_case": "O(n + k)",
          "worst_case": "O(n + k)"
        }
      },
      {
        "name": "Cycle Sort",
        "how_it_works": [
          "For each element, find its correct position.",
          "Swap the element with the element at its correct position.",
          "Repeat the process for all elements."
        ],
        "time_complexity": {
          "best_case": "O(n^2)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Cocktail Sort",
        "how_it_works": [
          "Perform a bubble sort in both directions.",
          "Repeat the process until the list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Strand Sort",
        "how_it_works": [
          "Create a sublist of sorted elements.",
          "Merge the sublist with the remaining elements.",
          "Repeat the process until all elements are sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Bitonic Sort",
        "how_it_works": [
          "Divide the list into bitonic sequences.",
          "Sort each bitonic sequence.",
          "Merge the sorted sequences."
        ],
        "time_complexity": {
          "best_case": "O(n log^2 n)",
          "average_case": "O(n log^2 n)",
          "worst_case": "O(n log^2 n)"
        }
      },
      {
        "name": "Pancake Sorting",
        "how_it_works": [
          "Find the largest element and flip it to the front.",
          "Flip the largest element to its correct position.",
          "Repeat the process for the remaining elements."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "BogoSort",
        "how_it_works": [
          "Randomly shuffle the list.",
          "Check if the list is sorted.",
          "Repeat the process until the list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O((n+1)!)",
          "worst_case": "O(∞)"
        }
      },
      {
        "name": "Gnome Sort",
        "how_it_works": [
          "Compare the current element with the previous element.",
          "If they are in the wrong order, swap them and move one step back.",
          "Repeat the process until the list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Sleep Sort",
        "how_it_works": [
          "Create a thread for each element.",
          "Sleep for a duration proportional to the element's value.",
          "Print the element after waking up."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n)",
          "worst_case": "O(n)"
        }
      },
      {
        "name": "Stooge Sort",
        "how_it_works": [
          "If the first element is larger than the last element, swap them.",
          "Recursively sort the first two-thirds and the last two-thirds of the list.",
          "Recursively sort the first two-thirds again."
        ],
        "time_complexity": {
          "best_case": "O(n^2.709)",
          "average_case": "O(n^2.709)",
          "worst_case": "O(n^2.709)"
        }
      },
      {
        "name": "Tree Sort",
        "how_it_works": [
          "Insert all elements into a binary search tree.",
          "Perform an in-order traversal to retrieve the sorted elements."
        ],
        "time_complexity": {
          "best_case": "O(n log n)",
          "average_case": "O(n log n)",
          "worst_case": "O(n^2)"
        }
      },
      {
        "name": "Odd-Even Sort / Brick Sort",
        "how_it_works": [
          "Compare and swap adjacent elements in odd and even indexed pairs.",
          "Repeat the process until the list is sorted."
        ],
        "time_complexity": {
          "best_case": "O(n)",
          "average_case": "O(n^2)",
          "worst_case": "O(n^2)"
        }
      }
    ]
  }